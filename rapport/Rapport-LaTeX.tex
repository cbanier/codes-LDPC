\documentclass[french,nochapter,11pt]{rapportUB}  
% Options french (1-) ou english (2-)
%    1- si vous rédigez en français (chargement du package [french]{babel})
%    2- si vous rédigez en anglais (chargement du package [english]{babel})
% Options chapter (1-) ou nochapter (2-)
%    1- la commande \chapter peut être utilisée dans le document (la classe report est chargée)
%    2- la commande \chapter NE peut PAS être utilisée dans le document (la classe article est chargée)
% Options 10pt ou 11pt ou 12pt (taille des caractères)
% Option nologo (à utiliser seulement si vous ne souhaitez pas afficher le logo de l'université sur la première page / le logo doit être dans le même dossier que votre fichier tex et s'appeler logo (l'extension n'a pas d'importance)
%
% Les options par défaut sont french, nochapter,11pt

\college{Collège Sciences et Technologies}
\uf{UF Mathématiques et Interactions - Informatique}
\program{Licence Mathématiques Informarique} %A remplir
\course{Projet tutoré} %A remplir
\academicyear{2020 -- 2021} %A remplir
\author{ %A remplir
  Corentin Banier
  \\
  Maher Karboul
}

%Paquetages additionnels
\usepackage{placeins}
\usepackage{multirow}
\usepackage{framed}
%Pour gérer la bibliographie
\usepackage[backend=bibtex,style=authoryear]{biblatex}
\addbibresource{biblio.bib}
\DeclareDelimFormat{nameyeardelim}{\addcomma\space}

%Déclaration d'un nouvel opérateur
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
%bib pour les matrices
\usepackage{amsmath}
\usepackage{arydshln}
\usepackage{amsfonts}

\begin{document}

\title{Codes LDPC}

\maketitle

\begin{center}
\tableofcontents %affichage de la table des matières
\clearpage
\end{center}

%-----------------------------------------------------
% IMPORTANT : A décommenter pour ajouter l'engagement de non plagiat au rapport.
%\nonplagiat{Prenom1 Nom1}[Prenom2 Nom2][Prenom3 Nom3]
%-----------------------------------------------------


\section{Introduction}
\label{sec:introduction}
La conception des codes LDPC binaires avec un faible poids d'erreurs demeurre un problème non entiérement résolu. 
Les codes LDPC (Low Density Parity Check) sont des codes linéaires correcteurs d'erreurs qui assurent la transmission d'informations. 
Ils forment une classe de codes en bloc qui se caractérisent par une matrice de contrôle creuse. Ils ont été décrits pour la première 
fois dans la thèse de Gallager au début des années 60. Dans ce travail , on va reprendre l'algorithme de Gallager et on va l'implémenter 
et l'analyse afin de l'optimiser au maximum.\newline
Le rapport est organisé de la manière suivante . La section \ref{sec:fabrication} présente les étapes de fabrication d'un code LDPC 
ainsi qu'une matrice de contrôle qui répond à des conditions bien spécifiques. La section \ref{sec:algo} présente l'algorithme 
détaillé de décodage LDPC. La section \ref{sec:exp} est dédiée aux expériences pratiques qu'on a effectué durant l'implémentation 
de l'algorithme. Enfin, la section \ref{sec:conclusion} sera notre conclusion sur le projet.

\subsection{Codes correcteurs}
Lors de la transmission d'une information , des erreurs peuvent se produire. Cette problématique de corrections des erreurs de transmission est très importante dans notre monde connecté, qu'il s'agisse des communications entre ordinateurs par internet, des conversations téléphoniques etc.. \newline
Un code correcteur, souvent désigné par le sigle anglais ECC (Error-correcting code), est une technique de codage basée sur la redondance. \newline
Un code est une application ijective $\Phi:\{0,1\}^k \rightarrow \{0,1\}^n $. \newline
Le paramètre k est appelé la \textbf{dimension} du code $\Phi$ et le paramètre n est appelé la \textbf{longueur} du code : on dit que $\Phi$ est un code de paramètres (k,n). \newline
Soit $\Phi$ un code d'image C . \newline
On appelle \textbf{capacité de correction} de $\Phi$ le plus grand entier $e_c$ tel qu'on soit toujours capable de corriger $e_c$ erreurs ou moins. \newline
On appelle \textbf{distance minimale} de $\Phi$ et on note $d_c$ la plus petite distance non nulle entre deux mots de code. \newline
On a \textbf{$e_c = $} $\frac{d_c-1}{2}$
Parmi les exemples de codes correcteurs qu'on peut citer: code de répétition, code carré et le code de Hamming
\subsubsection{Code de répétition}
Le code de répétition se résume par transmettre le message deux fois pour s'assurer contre les erreurs. Par exemple, Alice veut transmettre un mot de quatre bits à Bob. 
\begin{tabbing}
\hspace{5cm}\textbf{m=0111} \newline
\end{tabbing}
Elle va donc envoyer le mot codé
\begin{tabbing}
    \hspace{5cm}\textbf{c=01110111}
\end{tabbing}
le mot reçu par Bob sera noté y. Par exemple, si Bob reçoit
\begin{tabbing}
    \hspace{5cm}\textbf{y=01110110}
\end{tabbing}
Il peut constater qu'une erreur, au moins, s'est produite. Il peut dire que l'erreur est soit sur le quatrième ou le huitième bit.


\subsubsection{Code carré}
On suppose que Alice veut transmettre le mot de quatre bits, \textbf{m=$x_1$$x_2$$x_3$$x_4$}. Pour cela, elle l'écrit dans un carré de la façon suivante \newline
\begin{tabbing}
  \hspace{5cm} $x_1$ $x_2$ \\
  \hspace{5cm} $x_3$ $x_4$
\end{tabbing}
Elle rajoute ensuite les bits, dits de parité, $p_1$,$p_2$,$p_3$,$p_4$ de sorte qu'il y ait un nombre pair de 1 sur chaque ligne et chaque colonne. \newline
La somme sur chaque ligne et chaque colonne est 0 modulo 2. \newline
Le code sera affiché de cette façon :
\begin{tabbing}
  \hspace{5cm} $x_1$ $x_2$ $p_1$ \\
  \hspace{5cm} $x_3$ $x_4$ $p_2$ \\
  \hspace{5cm} $p_3$ $p_4$
\end{tabbing}
Le mot codé envoyé par Alice est : 
\begin{tabbing}
  \hspace{5cm}\textbf{c=$x_1$$x_2$$x_3$$x_4$$p_1$$p_2$$p_3$$p_4$}
\end{tabbing}
On prend l'exemple suivant : \textbf{m=0011}, la première étape est :
\begin{tabbing}
  \hspace{5cm}\textbf{0 0} \\
  \hspace{5cm}\textbf{1 1}
\end{tabbing}
En rajoutant les bits de parité, on obtient
\begin{tabbing}
  \hspace{5cm}\textbf{0 0 0}\\
  \hspace{5cm}\textbf{1 1 0 }\\
  \hspace{5cm}\textbf{1 1}
\end{tabbing}
Le mot codé est donc \textbf{c=00110011}





\subsubsection{Code linéaire}
\textbf{Définition:} Soient $\mathbb{F_q}$ un corps fini à q éléments, n$\geq$1 un entier. On dit que C $\subset$ $\mathbb{F_q}^n$ est un code linéaire si C est un sous-espace vectoriel de $\mathbb{F_q}^n$. Comme tout espace vectoriel, C a une dimension k. \newline
La construction de ce type de code est : $\phi$: $\mathbb{F_q}^k$ $\to$ $\mathbb{F_q}^n$. D'où C=Im$\phi$ est un sous espace-vectoriel de $\mathbb{F_q}^n$, et par le théorème du rang dimC = k. \newline
\textbf{Exemple de code linéaire:} Le code carré. 

\subsection{Matrice génératrice}
\textbf{Définition d'une matrice génératrice:} Soit C $\subset$ $\mathbb{F_q}^n$ un code linéaire de dimension k. Une matrice G dont les lignes forment une forme de C s'appelle \textbf{matrice génératrice} de C. Elle aura donc k lignes et n colonnes. \newline
\textbf{Exemple:} \textbf{Le code carré:}On rappelle que c'est l'image de l'application linéaire injective \newline 
 
$\begin{array}{cccc}
  \phi :  \mathcal{F}_2^4 \to  \mathcal{F}_2^8 \cr
(x_1,x_2,x_3,x_4) \mapsto (x_1,x_2,x_3,x_4,x_1+x_2,x_3+x_4,x_1+x_3,x_2+x_4)
\end{array}$
\newline
Une base de l'image est l'image d'une base. Par exemple l'image de la base  canonique. \newline
Donc $\phi(1000)$ = \textbf{10001010} \newline
$\phi(0100)$ = \textbf{01001001} . \newline
De même pour $\phi(0010)$=\textbf{00100110} \newline
Et aussi $\phi(0001)$ = \textbf{00010101} \newline
On obtient donc une matrice génératrice
$$G=
\begin{pmatrix}
  1 & 0 & 0 & 0 & 1 & 0 & 1 & 0  \\
  0 & 1 & 0 & 0 & 1 & 0 & 0 & 1  \\
  0 & 0 & 1 & 0 & 0 & 1 & 1 & 0  \\
  0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 
  
  
\end{pmatrix}
\quad
$$

\subsection{Syndrome}
Soient C un code linéaire et H une matrice de contrôle de C. Un mot x de C est transmis. y est le mot reçu. \newline
On pose r = y - x l'erreur de transmission. Ce qui implique que y = r + x \newline
On a donc:
\begin{tabbing}
  \hspace{5cm} H$~^ty$ = H$~^t(x + r)$= H$~^tx$ + H$~^tr$  = H$~^tr$ 
\end{tabbing}
car H$~^tx$ =0 vu que x est un mot de C.
Donc la méthode de décodage par syndrome permet de repèrer les indices érronés dans un code reçu à l'aide de la matrice de contrôle.

\vspace{0.8cm}
Dans la suite du document, la section \ref{sec:fabrication} présente la formalisation du problème.


\section{Comment fabrique-t-on un code LDPC ?}
\label{sec:fabrication}
Les codes LDPC ont été découverts par Gallager dans les années 60, mais il a proposé seulement une méthode générale pour construire des codes LDPC pseudo-aléatoire. \newline
Les longs codes LDPC sont générés par des ordinateurs et leur décodage est complexe dû au manque de structure. Tanner , en 1981, a donné une nouvelle interprétation d'un point de vue graphique qui a contribué au décodage itératif. \newline
La première construction algébrique et systématique de codes LDPC basée sur les géométries finies a été proposée par Lin,Kou et Fossorier dans les années 2000. \newline
La construction et le décodage des codes LDPC peuvent être fait de plusieurs manières. Un code LDPC est caractérisé par sa matrice de parité. \newline
\textbf{Définition des codes LDPC:} Un code LDPC régulier est défini comme l'espace nul d'une matrice de contrôle de parité H, qui a les propriétés suivantes: \newline
(1) chaque ligne et colonne contient un nombre bien défini de 1
(2) ce nombre là a une valeur petite en comparaison avec la longueur du code et avec le nombre de lignes de H. \newline
La matrice H est une \textbf{matrice creuse}: elle a une faible densité de valeurs de 1. \newline
Dans le cas où toutes les colonnes ou toutes les lignes de H n'ont pas le même poids, le code LDPC s'appelle \textbf{code LDPC irrégulier}. \newline

\textbf{Construction des codes LDPC:} La construction d'un code LDPC binaires revient à attribuer un petit nombre de valeurs dans une matrice de zéros à 1. Plusieurs méthodes pour construire de bons codes LDPC peuvent être résumées en deux classes principales : \textbf{constructions aléatoires et structurelles}.
La première classe est basée sur des géométries finies, alors que la deuxième méthode des basée sur des matrices de permutation circulantes. \newline
Dans ce travail, on va mettre l'accent sur la deuxième catégorie. \newline
\subsection{Construction des codes LDPC de Gallager}
Afin de construire la matrice de parité \textbf{H} d'un code LDPC de Gallager, il faut d'abord construire une sous matrice \textbf{$H_i$} ayant un poids de colonnes égal à 1 et un poids de lignes $\gamma$. Ensuite on doit trouver des permutations de colonnes de cette sous-matrice afin de former les autres sous-matrices avec lesquels on forme la \textbf{matrice de Gallager} de la manière suivante :
$$H=
\begin{bmatrix}
  H_1 \\
  H_2 \\
  H_3 \\
  \vdots \\
  H_7
\end{bmatrix}
\quad
$$
\newline
Lorsqu'on choisit les permutations de colonnes des sous-matrices il faut faire attention à garder une bonne distance minimale de la matrice de parité \textbf{H}.
\subsection{Exemple de construction de Gallager}
Les lignes de contrôle de parité des matrices de Gallager sont divisées en ensemble $w_c$ avec $\frac{M}{w_r}$ lignes dans chaque série. Le premier ensemble de lignes contient $w_r$ nombre de '1' consécutifs ordonnés de gauche à droite à travers les colonnes, ce qui veut dire que pour i $\leq$$\frac{M}{w_r}$, la i\up{ème} ligne n'est pas nulle de la ((i-1)+1\up{ème}) jusqu'à la i$w_r$\up{ème} colonne). \newline
Par conséquent, toutes les colonnes de \textbf{H} comportent un seul '1' dans chacun des ensembles $w_c$. \newline \newline
\textbf{Exemple:} Une matrice de controle de parité régulière(Gallager) tels que : M=10 (colonnes), $w_c$=3, $w_r$= 5\newline

$$H=
\begin{bmatrix}
  1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 \\
  0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\
  \hdashline
  1 & 0 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 1 \\
  0 & 1 & 0 & 1 & 1 & 0 & 1 & 0 & 1 & 0 \\
  \hdashline
  1 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 1 \\
  0 & 0 & 1 & 1 & 0 & 1 & 0 & 1 & 1 & 0 
  
\end{bmatrix}
\quad
$$

\section{Graphe de Tanner}
Dans la théorie du code , un \textbf{graphe de Tanner}, nommé après Michael Tanner , est un graphe biparti utilisé pour indiquer des contraintes ou des équations spécifiques aux codes correcteurs d'erreurs. Dans cette théorie, les graphes de Tanner sont utilisés pour créer des codes longs à partir de codes plus courts. Ce graphe est utilisé de manière intensive dans le codage et le décodage. \newline
\begin{tabbing}
  Le \textbf{graphe de Tanner} se compose en : \\
  \hspace{2cm}\textbf{Noeuds de variables:} associés aux bits du mot de code\\
  \hspace{2cm}\textbf{Noeuds de parité:} associés aux équations de parité\\
  \hspace{2cm}\textbf{Branches:} lien entre noeuds de variables et noeuds de parité. Un noeud de variable n est connecté au noeud de parité m si $h_mn$ = 1 dans la matrice de parité H.
\end{tabbing}
\textbf{Exemple: Graphe de Tanner du code de Hamming} \newline
Soit la matrice de Parité : \newline
$$H=
\begin{pmatrix}
  1 & 0 & 1 & 0 & 1 & 0 & 1 \\
  0 & 1 & 1 & 0 & 0 & 1 & 1  \\
  
  0 & 0 & 0 & 1 & 1 & 1 & 1  
  
  
\end{pmatrix}
\quad
$$
Les coefficients $H_{11}$, $H_{13}$, $H_{15}$ et $H_{17}$ sont égaux à 1 donc le noeud $c_1$ est relié aux noeuds $v_1$, $v_3$, $v_5$ et $v_7$ . \newline
Les coefficients $H_{22}$, $H_{23}$, $H_{26}$ et $H_{27}$ sont égaux à 1 donc le noeud $c_2$ est relié aux noeuds $v_2$, $v_3$, $v_6$ et $v_7$ . \newline
De même, Les coefficients $H_{34}$, $H_{35}$, $H_{36}$ et $H_{37}$ sont égaux à 1 donc le noeud $c_3$ est relié aux noeuds $v_4$, $v_5$, $v_6$ et $v_7$ . \newline


Le graphe de Tanner associé : \newline
INSERER L'IMAGE 1  ICI \newline
\textbf{Autre exemple:}
Soit la matrice de Parité : \newline
$$H=
\begin{pmatrix}
  1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
  0 & 1 & 0 & 0 & 1 & 1 & 0 & 0 \\
  
  0 & 0 & 1 & 0 & 0 & 1 & 1 & 0 \\
  0 & 0 & 0 & 1 & 0 & 0 & 1 & 1 
  
  
\end{pmatrix}
\quad
$$
Le graphe biparti de Tanner associé : \newline

Inserer l'image 2 ici !! \newline

Le graphe de Tanner est utilisé comme support pour la plupart des algorithmes de décodage. Le principe principal d'un algorithme de décodage utilisant cette représentation est de considérer chaque branche du graphe comme un message d'un noeud $c_j$ vers un noeud $v_i$ et réciproquement.


\subsection{Vocabulaire}



\section{Algorithmes de décodage}
\label{sec:algo}

Pour écrire des algorithmes, le paquetage suivant est très utile : \url{http://tug.ctan.org/macros/latex/contrib/algorithm2e/doc/algorithm2e.pdf}  


\section{Expérimentations et résultats}
\label{sec:exp}

La Table \ref{table:resultats} présente un résumé des résultats de nos expérimentations. 

\begin{table}[htbp]
  \centering
  \caption{Comparaison des différentes méthodes}
  \label{table:resultats}
    \begin{tabular}{l|rrrrr}
    \hline
    \multirow{2}[0]{*}{Algorithme}&  \multicolumn{2}{c}{Temps CPU (ms)}  & \multicolumn{2}{c}{Gap MS} &  \multirow{2}[0]{*}{\#Données MS}  \\
        & \multicolumn{1}{c}{Moyenne}   & \multicolumn{1}{c}{Ecart type} & \multicolumn{1}{c}{Moyenne} & \multicolumn{1}{c}{Ecart type} & \\
          \hline
    Heuristique PPV & 29 & 96 & 8.4\% & \textbf{36\%} &  6/38\\
    Heuristique MI & 16984 & 78093  & \textbf{1.3\%} & 42\% &   \textbf{30/38} \\
    \hline
    \end{tabular}%
\end{table}%

\FloatBarrier

\section{Conclusion}
\label{sec:conclusion}
C'est la fin.


%% Les appendices commencent après la commande \appendix
%% Les commandes \chapter (si l'option chapter est sélectionnée), \section, \subsection peuvent s'utiliser comme habituellement
%\appendix

%\clearpage % à utiliser pour afficher la biblographie sur une nouvelle page
% References

%\printbibliography


\end{document}
